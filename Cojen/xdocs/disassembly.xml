<?xml version="1.0" encoding="ISO-8859-1"?>

<document>

 <properties>
  <title>Disassembly</title>
  <author email="broneill@users.sourceforge.net">Brian S O'Neill</author>
 </properties>

<body>

<section name="Class disassembly">

<p>
A <a href="apidocs/cojen/classfile/DisassemblyTool.html">disassembly</a> tool is provided
which serves as a generic class disassembler. It also supports an output format which
demonstrates how to use the Cojen API.
</p>

<p>
The disassembly tool can disasseble a class specified by a file path or by class name.
For example, the standard String class can be disassembled as follows:
</p>

<source>
java cojen.classfile.DisassemblyTool java.lang.String
</source>

<p>
The disassembly tool supports a format option, which can be "assembly" or
"builder". If not specified, it defaults to "assembly".  Here is sample output
generated by disassembling one of Cojen's utility classes, in assembly format:
</p>

<source>
/**
 * Originally compiled from "BeanIntrospector.java".
 */
public class cojen.util.BeanIntrospector extends java.lang.Object {
    /**
     * @synthetic
     */
    static java.lang.Class class$java$lang$Object;

    private static java.util.Map cPropertiesCache;

    static {
        // max stack: 2
        // max locals: 0
        // line 35
        new cojen.util.WeakIdentityMap
        dup
        invokespecial void cojen.util.WeakIdentityMap.&lt;init&gt;()
        putstatic java.util.Map cojen.util.BeanIntrospector.cPropertiesCache
        return
    }

    public static void main(java.lang.String[])
        throws java.lang.Exception
    {
        // max stack: 3
        // max locals: 1
        // line 38
        getstatic java.io.PrintStream java.lang.System.out
        aload_0
        iconst_0
        aaload
        invokestatic java.lang.Class java.lang.Class.forName(java.lang.String)
        invokestatic java.util.Map cojen.util.BeanIntrospector.getAllProperties(java.lang.Class)
        invokevirtual void java.io.PrintStream.println(java.lang.Object)
        // line 39
        return
    }

    ...

}
</source>

<p>
When disassembled using the builder format, a valid Java source file is generated which
when compiled and run, rebuilds the original class. This demonstrates how to use Cojen, and
it also allows Java classes to be modified when source code is not available.
</p>

<p>
Even if the generated class file builder is run without modification, the emitted class file
will likely produce a different binary representation than the original class. This is because
Cojen re-orders the class constant pool and reduces local variable usage.
</p>

<source>
java cojen.classfile.DisassemblyTool -f builder cojen.util.BeanIntrospector
</source>

<source>
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStream;

import cojen.classfile.ClassFile;
import cojen.classfile.CodeBuilder;
import cojen.classfile.FieldInfo;
import cojen.classfile.Label;
import cojen.classfile.LocalVariable;
import cojen.classfile.Location;
import cojen.classfile.MethodInfo;
import cojen.classfile.Modifiers;
import cojen.classfile.Opcode;
import cojen.classfile.TypeDesc;

/**
 * Builds ClassFile for cojen.util.BeanIntrospector
 *
 * @author auto-generated
 */
public class ClassFileBuilder {
    public static void main(String[] args) throws Exception {
        // public class cojen.util.BeanIntrospector
        ClassFile cf = createClassFile();

        if (args.length &gt; 0) {
            File file = new File(args[0]);
            if (file.isDirectory()) {
                writeClassFiles(cf, file);
            } else {
                OutputStream out = new BufferedOutputStream(new FileOutputStream(file));
                cf.writeTo(out);
                out.close();
            }
        }
    }

    private static void writeClassFiles(ClassFile cf, File dir) throws Exception {
        File file = new File(dir, cf.getClassName().replace('.', '/') + ".class");
        file.getParentFile().mkdirs();
        OutputStream out = new BufferedOutputStream(new FileOutputStream(file));
        cf.writeTo(out);
        out.close();

        ClassFile[] innerClasses = cf.getInnerClasses();
        for (int i=0; i&lt;innerClasses.length; i++) {
            writeClassFiles(innerClasses[i], dir);
        }
    }

    public static ClassFile createClassFile() {
        ClassFile cf = new ClassFile("cojen.util.BeanIntrospector", "java.lang.Object");
        cf.setSourceFile("BeanIntrospector.java");

        createStaticInitializer(cf);

        //
        // Create fields
        //

        cf.addField(Modifiers.PRIVATE.toStatic(true),
                    "cPropertiesCache",
                    TypeDesc.forClass("java.util.Map"));

        FieldInfo fi = cf.addField(Modifiers.NONE.toStatic(true),
                                   "class$java$lang$Object",
                                   TypeDesc.forClass("java.lang.Class"));
        fi.markSynthetic();

        //
        // Create constructors
        //

        // public void &lt;init&gt;()
        createConstructor_1(cf);

        //
        // Create methods
        //

        // public static void main(java.lang.String[])
        createMethod_1(cf);

        // public static java.util.Map getAllProperties(java.lang.Class)
        createMethod_2(cf);

        ...

        return cf;
    }

    private static void createStaticInitializer(ClassFile cf) {
        MethodInfo mi = cf.addInitializer();
        CodeBuilder b = new CodeBuilder(mi);

        b.mapLineNumber(35);
        TypeDesc type_1 = TypeDesc.forClass("cojen.util.WeakIdentityMap");
        b.newObject(type_1);
        b.dup();
        b.invokeConstructor("cojen.util.WeakIdentityMap", null);
        TypeDesc type_2 = TypeDesc.forClass("java.util.Map");
        b.storeStaticField("cPropertiesCache", type_2);
        b.returnVoid();
    }

    // public void &lt;init&gt;()
    private static void createConstructor_1(ClassFile cf) {
        MethodInfo mi = cf.addConstructor(Modifiers.PUBLIC, null);
        CodeBuilder b = new CodeBuilder(mi);

        b.mapLineNumber(33);
        b.loadThis();
        b.invokeSuperConstructor(null);

        b.mapLineNumber(307);
        b.returnVoid();
    }

    // public static void main(java.lang.String[])
    private static void createMethod_1(ClassFile cf) {
        MethodInfo mi = cf.addMethod(Modifiers.PUBLIC_STATIC,
                                     "main",
                                     null,
                                     new TypeDesc[] {TypeDesc.STRING.toArrayType()});
        mi.addException("java.lang.Exception");
        CodeBuilder b = new CodeBuilder(mi);

        LocalVariable var_1 = b.getParameter(0);

        b.mapLineNumber(38);
        TypeDesc type_1 = TypeDesc.forClass("java.io.PrintStream");
        b.loadStaticField("java.lang.System", "out", type_1);
        b.loadLocal(var_1);
        b.loadConstant(0);
        b.loadFromArray(TypeDesc.OBJECT);
        TypeDesc type_2 = TypeDesc.forClass("java.lang.Class");
        TypeDesc[] params_1 = new TypeDesc[] {TypeDesc.STRING};
        b.invokeStatic("java.lang.Class", "forName", type_2, params_1);
        TypeDesc type_3 = TypeDesc.forClass("java.util.Map");
        TypeDesc[] params_2 = new TypeDesc[] {type_2};
        b.invokeStatic("getAllProperties", type_3, params_2);
        TypeDesc[] params_3 = new TypeDesc[] {TypeDesc.OBJECT};
        b.invokeVirtual("java.io.PrintStream", "println", null, params_3);

        b.mapLineNumber(39);
        b.returnVoid();
    }

    ...

}
</source>

</section>

</body>
</document>
